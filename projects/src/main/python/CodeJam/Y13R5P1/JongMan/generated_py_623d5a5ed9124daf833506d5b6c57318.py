import sys
sys.path.append('/home/george2/Raise/ProgramRepair/CodeSeer/projects/src/main/python')
from CodeJam.Y13R5P1.JongMan.roulette2 import *

def func_b3607c87abf94237a6dc3992ce5b3f09(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    return partial


def func_af4aecab5b3b43698a7d87c2fc9612eb(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    return p


def func_1ef2d23a5b9742beb274b24a8661c68f(lowest_cnt):
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    return ret


def func_1f456037a7f44e88abe43a7664d8dc38(lowest_cnt, lowest, only_mine):
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    return ret


def func_f92bd295d2984f4d80cbf903837be8a2(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    return only_mine


def func_b4571d5f4f5e4f2291203ec3b53b1b57(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    return partial


def func_89207f0081b24f9c882a0fe8ff87e567(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    return p


def func_aa6ff703a869404ab5ccba8fb314dcdc(lowest_cnt, lowest, only_mine):
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    return ret


def func_05b034cd4596424aa9f727b25ae9799a(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    return lowest_cnt


def func_ee77ce06116d4dbf8dcdf4271624d151(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    return partial


def func_425d397183b445779a8913011fabce9d(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    return only_mine


def func_d1b63fd727154d62a0e51091702505a1(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    return p


def func_56650768666e4576b35c08ae0a8f3869(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    return p


def func_5ad99e5dabca410e8c85829604e3b7c3(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    return only_mine


def func_cd60b6989fa34950b4f881aa607c9ec1(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    return partial


def func_cc50f64d990a4d2c9d17839f0df99e5c(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    return lowest_cnt


def func_cace8cb98f8a477ca8abb3e96100f1ed(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    return only_mine


def func_9d1a53f5eae243e3a8a282b0e61e67b1(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    return ret


def func_a67fb82fe9964d89bbcfd06cc1ffd4fc(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    return p


def func_8d71ceedbe7e4d099e7ac25c72a969cf(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    return lowest_cnt


def func_debb2352e83b4aa3ba817d1a93fed623(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    return partial


def func_f3c397f88f4647b5bdd387cf7f939f7f(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    return lowest_cnt


def func_4e416694a021440aae7bd0243ccc6343(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    return only_mine


def func_9bea198fe2ef47838825c59464b01660(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    return partial


def func_8ca5932e47da4ec395984bc0243ac390(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    return ret


def func_0a833f94d5dc457ab03800aecff043da(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    return p


def func_b5023ac8c4654db2b4c81f5440079cf4(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    for p in partial:
        ret += 36.0 * (lowest - p) * 1.0 / lowest_cnt
    return only_mine


def func_93fb4b4a66cf4947801fa25a5f3905ad(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    for p in partial:
        ret += 36.0 * (lowest - p) * 1.0 / lowest_cnt
    return partial


def func_2054f2fcfa7e41dbb4a8573d899868ef(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    for p in partial:
        ret += 36.0 * (lowest - p) * 1.0 / lowest_cnt
    return ret


def func_16fc15362ae44de382a7cf8b6300aaf0(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    for p in partial:
        ret += 36.0 * (lowest - p) * 1.0 / lowest_cnt
    return p


def func_313ca3bbd50b4776b8e1cdd5a4237c60(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    for p in partial:
        ret += 36.0 * (lowest - p) * 1.0 / lowest_cnt
    return lowest_cnt


def func_8ccb6be215f946c096f353ecc7e1f8ad(lowest, placed, override):
    partial = [p for p in placed if p <= lowest]
    if override > 0:
        partial = partial[:-override]
    only_mine = 37 - len(placed)
    lowest_cnt = only_mine + len(partial)
    if lowest_cnt == 0:
        return 0
    ret = 0.0
    ret += lowest * 36.0 * only_mine / float(lowest_cnt)
    for p in partial:
        ret += 36.0 * (lowest - p) * 1.0 / lowest_cnt
    return ret


def func_e1a520bf58c74b5f95fd5e1fb9835983(lowest_cnt, lowest,
    remaining_budget, can_replicate, larger):
    next_larger = min(larger)
    can_replicate = min(next_larger - lowest - 1, remaining_budget / lowest_cnt
        )
    return next_larger


def func_717b5659538b41bd88c3ece95f35a098(lowest, placed, exclude,
    needed_budget):
    cand = get_expected(placed, lowest, exclude) - exclude - needed_budget
    ret = max(ret, cand)
    return ret


def func_53abe815e79f40a1b75b6da20024e6e1(lowest, placed, exclude,
    needed_budget):
    cand = get_expected(placed, lowest, exclude) - exclude - needed_budget
    ret = max(ret, cand)
    return cand


def func_0a79f5bb24484ca39aec13faa8111d46(lowest, placed):
    needed_budget = (37 - len(placed)) * lowest
    for p in placed:
        needed_budget += max(0, lowest - p)
    return needed_budget


def func_ab9640aa475841d6891a8dee2b2ca9c4(lowest, placed):
    needed_budget = (37 - len(placed)) * lowest
    for p in placed:
        needed_budget += max(0, lowest - p)
    return p


def func_586c631fab234f4abee0ae2b83a97524(lowest, budget, placed, needed_budget
    ):
    remaining_budget = budget - needed_budget
    partial = len([p for p in placed if p <= lowest])
    return p


def func_4c057f6f577c4d45b063e72434a1a8b9(lowest, budget, placed, needed_budget
    ):
    remaining_budget = budget - needed_budget
    partial = len([p for p in placed if p <= lowest])
    return remaining_budget


def func_f786d824fa0743ab91f810f4b5b2ecc6(lowest, budget, placed, needed_budget
    ):
    remaining_budget = budget - needed_budget
    partial = len([p for p in placed if p <= lowest])
    return partial


def func_239cff9d8f2a4c149f4bee34d2a26c66(lowest, placed):
    partial = len([p for p in placed if p <= lowest])
    lowest_cnt = 37 - len(placed) + partial
    return partial


def func_1faf349b06954d568194f1b2fdc2a331(lowest, placed):
    partial = len([p for p in placed if p <= lowest])
    lowest_cnt = 37 - len(placed) + partial
    return p


def func_9e543731501f45b7a9f7111e08dc6fee(lowest, placed):
    partial = len([p for p in placed if p <= lowest])
    lowest_cnt = 37 - len(placed) + partial
    return lowest_cnt


def func_a10e776df323436c80bf480b9fc7a7ca(lowest_cnt, lowest,
    remaining_budget, can_replicate, placed):
    larger = [p for p in placed if p > lowest]
    if larger:
        next_larger = min(larger)
        can_replicate = min(next_larger - lowest - 1, remaining_budget /
            lowest_cnt)
    else:
        can_replicate = remaining_budget / lowest_cnt
    return larger


def func_6d48a285cace454baa0cbf40e34a8ace(lowest_cnt, lowest,
    remaining_budget, can_replicate, placed):
    larger = [p for p in placed if p > lowest]
    if larger:
        next_larger = min(larger)
        can_replicate = min(next_larger - lowest - 1, remaining_budget /
            lowest_cnt)
    else:
        can_replicate = remaining_budget / lowest_cnt
    return next_larger


def func_faa8e882935c4474ab27832a082ddeb4(lowest_cnt, lowest,
    remaining_budget, can_replicate, placed):
    larger = [p for p in placed if p > lowest]
    if larger:
        next_larger = min(larger)
        can_replicate = min(next_larger - lowest - 1, remaining_budget /
            lowest_cnt)
    else:
        can_replicate = remaining_budget / lowest_cnt
    return p


def func_0ccd2127f2214a5caa91cd8829a4d56d(lowest, budget, placed, needed_budget
    ):
    remaining_budget = budget - needed_budget
    partial = len([p for p in placed if p <= lowest])
    lowest_cnt = 37 - len(placed) + partial
    return p


def func_823ff6d2a5a745c2b4d5c99dca6bf1f8(lowest, budget, placed, needed_budget
    ):
    remaining_budget = budget - needed_budget
    partial = len([p for p in placed if p <= lowest])
    lowest_cnt = 37 - len(placed) + partial
    return lowest_cnt


def func_d61fa8489acc46ac8c5a3d2490865ffb(lowest, budget, placed, needed_budget
    ):
    remaining_budget = budget - needed_budget
    partial = len([p for p in placed if p <= lowest])
    lowest_cnt = 37 - len(placed) + partial
    return remaining_budget


def func_365835b6f7484ef28c09afbc58638e15(lowest, budget, placed, needed_budget
    ):
    remaining_budget = budget - needed_budget
    partial = len([p for p in placed if p <= lowest])
    lowest_cnt = 37 - len(placed) + partial
    return partial


def func_6875a669551a4eba80d27edaf9ab29da(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    return budget


def func_083d5dfe2aed4a6f8e8cc78f4922fe2a(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    return bets


def func_e4af148c84f94b669df248bb3bfc5a36(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    return placed


def func_37511302e85e4608a016bf88c5d04943(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    return placed


def func_a629d90826ed496883b5466c5eb53a3f(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    return ret


def func_83b242b2d1fa4e4fa7bca9942c560ab2(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return queue


def func_4b8e3f3803e8494aa0b4c9d0dcdae0a8(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return ret


def func_7d4ef7b2dd064ef093c471ba71ceeb2f(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return p


def func_b163268f8ff64d3f84e3aaa6d8010b7b(placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return queue


def func_6ef8e71e217a4110bac33d08a52272ad(placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return p


def func_88c0d8eea3ce4744a926669c6082994e():
    queue = sorted(set(queue))
    seen = set(queue)
    return queue


def func_49238305546a42b88fab1e662bc3886f():
    queue = sorted(set(queue))
    seen = set(queue)
    return seen


def func_ce981d0535964624bf3ee9531c331713(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    return ret


def func_c1fd60988f424224aad069548db86cb3(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    return bets


def func_a5ecdfa35a234ecab08849a0d96e3eb5(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    return placed


def func_6a2ab7d45b58407abcc316b7add8fc78(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    return budget


def func_26126a771ebf4efba104529689bafd56(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return placed


def func_f59c5bdd3baf4e7ba6fa44bcdc21f8ad(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return p


def func_31618675966746e8a3b27760bcb0835c(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return queue


def func_99f09453144841aba7d754444625a900(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return ret


def func_7712e59f1d0f481fbe89bcc5f0aac879(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return ret


def func_a8c596f467194fb1b2d14694fa657671(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return queue


def func_46d8aef8af3a4db38f56975d1aefd163(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return p


def func_adbd3f3140124e6190f58d7026e60ce3(placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return seen


def func_024786bb17704b50afeed4c0be4abf3d(placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return p


def func_85f0ac2c5e5c456f8d538f8e34213058(placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return queue


def func_a9f293f95d944e7d866f0d196e3e2d57(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return ret


def func_4be1d115232a411493011c98316bf5c7(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return partial


def func_60f3a5452e9747acb6450bf5dca833d1(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return larger


def func_173eab38ea1a4067bff3779d02068566(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest


def func_1cb3add9f5a244d4bf75fcdf4c1e97d0(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return exclude


def func_35a92a405dda4aa9bdd5424b16d64394(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return remaining_budget


def func_f965f33635b54fdab6bef89dfcc89751(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return queue


def func_54ebca06e8c94c8fbe08cbcacdc1a7c5(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest_cnt


def func_2dc61e8836d049228aa560f269cf6212(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return needed_budget


def func_848e3dd00b6f4a5587339e269a2ac980(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return next_larger


def func_9201b586d2bb48b1b67b9c2ac979bc7d(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return p


def func_f258f5e37b604b3da0ac0c85a02982f0(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return seen


def func_3e01a7e9d3e2479287aa5ceed777784a(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return can_replicate


def func_7c6f95a6417c4872883e34c1b0b51dd9(budget, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return cand


def func_7543941daf1f4f038456594e7b6e7269(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return bets


def func_e0497990b4ef4b0d83a4c7d4be2c85d6(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return p


def func_dec1e042c1ce4a9ea4eab8d6605b2690(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return budget


def func_b73b99b05a6f4a4b87086ec200248db7(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return placed


def func_bb98bb02b80941f8982743aaba5991eb(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return ret


def func_435d5f517c2742029461a81bb808dceb(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    return queue


def func_f99950bcfbc3464abfbef40a5ea4cdf0(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return queue


def func_9235167e61604887b366097ed2b99239(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return p


def func_ffc8073941f740ed9fb51309802b4fdb(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return ret


def func_0041b49d8afa4ef18301fdeacea88257(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return placed


def func_265673fa1dd840d7aa17bb82706d27b9(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return p


def func_a0056a7262b441039860d046ca992b88(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return ret


def func_9c11471050fc48fe9e5f7facb70e4c26(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return queue


def func_4f865c4a702244d1be54f33203b0b368(placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return seen


def func_9243d7ed6d9b48cba0d746db46cd269f(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return remaining_budget


def func_4e393aa5f5584bf8bd8a2742b11c1776(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return seen


def func_ae9c66516d354391864931f32ed23dcd(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return ret


def func_418acfab21b341c7863b413014cddc82(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return cand


def func_016c2c5ca7e4470c969584bfc6cd72f1(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return next_larger


def func_d0d3c841431f47e4b717a1b7c577396c(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return queue


def func_72b2d94a87b147aabe50336749e37879(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return exclude


def func_67eee9de990443e085ab6d1167d499a4(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return partial


def func_462da3106c414a9c91acd8f9f47cbdfd(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return needed_budget


def func_8d11fb75c9f64f649744f56293634ca3(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return can_replicate


def func_2c657999f97648419f4bb97200dffaaf(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest


def func_7e43943e75a34c27a22b76c99d5f1a9d(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest_cnt


def func_d62de335f450463198e1ef3d73e36a60(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return p


def func_5cd38c58d4cf427db53336b6d407c668(budget, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return larger


def func_7b0a748f0d1748a7826768d5660e8fea(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return can_replicate


def func_10daafd3c0f648b48d0c629b51d9a68d(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return needed_budget


def func_c7d838ac8c7a4a8d9d8e58f411210adb(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return p


def func_d17f06f02f8a459ab2621e9229925209(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return partial


def func_193c4bae9b8c4b288a64ffceaa1357da(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return remaining_budget


def func_f2cea0e383194413943eeeb713f132a0(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return larger


def func_79e6f9e552d54076b8120b78f1b74c16(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return queue


def func_acb5e7a6c4d542c796f44042db9c89b8(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return cand


def func_d4514fa8f2204062acede068a879b881(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return ret


def func_b771b5acc080494ba562adf4b3409267(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return next_larger


def func_d24eaae067a54042849fed825d87a2a5(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest


def func_ea3a8ec07d5c4b75aa68097c3cfc2056(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest_cnt


def func_d2edd5919d3b4bc09e86f1823ee8b3f8(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return seen


def func_e9244afb5e0b4516abbabd813bacfda3(budget, cc, placed):
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return exclude


def func_8a3eedaae84a4ac0a4ababa1da21a8fd(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return p


def func_025cba4c7ac748a599cb834cf3359f00(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return queue


def func_7b7feac682d94ac7ba4d052bda8ee83d(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return ret


def func_5ac0bcb86df047dbb63f820394789752(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return budget


def func_7545214d91974685b68063f41ddd4dc8(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return bets


def func_32342c9481784983ae6f68d22a4508a7(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    return placed


def func_4333d964f5cf4636bb9ee15c636daa77(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return ret


def func_2b817e14313045ebab7dbfcb94ea801c(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return queue


def func_211e5dca28ea42e483294e4cd1a9b770(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return p


def func_ecb447c251bc40a98ebfe5c4a441968f(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return seen


def func_fd243e02442d4db8951cfbae96c60fde(infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return placed


def func_ef66c0f32e634e5196fd6c5806fbeb73(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return next_larger


def func_66ab7686dc274650a64d0b0bd841ecd9(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return cand


def func_6ea4ecb0027249d48d09c0e44f86592f(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return queue


def func_5aaaeb947cf24badb29d2bfade201bf8(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return partial


def func_145ea1523499472c8e10a32d1d4fcc0b(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return larger


def func_f3643d51ae9b4dcfa05275ff84e994a0(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return exclude


def func_fa5826c503454255b6e198c489d3338d(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return remaining_budget


def func_346669cf7fdb42f08a0d0e1ae00d3231(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return needed_budget


def func_9b879c5d032e4dc8a93bd1e06ad3c777(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest_cnt


def func_9fce7021afb7428f97af9c8f9bfc453e(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return can_replicate


def func_74ddda17a48d4ad8a71f939e6f1d2a07(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest


def func_934d186d2493471f97a636549a9d331d(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return ret


def func_0c00f14afddb48daa8444e73770dc1d5(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return seen


def func_5252f512145a427aa25a240b2477d5bf(budget, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return p


def func_96c52d559dfc4958900f75d7a7bbf83d(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return needed_budget


def func_543644ca3582410e8a52a5495730db23(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return queue


def func_dee43b4a4abe4ddab0704e3cec0c8ddb(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return p


def func_b3f12384b40e4e678c884d41caf319d2(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return ret


def func_f29e053c2e1e4b2ea0fb8efd05c00b42(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return cand


def func_72494d8167ad41afb91c9461e5d7af22(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return larger


def func_0ff370eaca534bafab02aa14500b9415(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return seen


def func_181e3ae275e54f6cae304228d5016090(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest_cnt


def func_2cf9d754159a457eb28b55daeb235fd9(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return exclude


def func_d40062eb1a3948898baf065f86f0ede1(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return partial


def func_b95d26c918f344458c6ebe66b7051767(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return can_replicate


def func_d8567a2bad1d46c6a23c6ce20a31d8c8(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return remaining_budget


def func_13aba82267cd4457a8a1e4b63b44aa3d(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest


def func_fc176ac0bfb34c2691613ec2a5fdc75c(budget, cc, placed):
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return next_larger


def func_2d49266271214aaa95d35f24b76ec595(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return seen


def func_f2b717277015480aa81aead5107e1714(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return queue


def func_55991d4d81b847b5ab9c935dd4740b43(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return ret


def func_ea807d1ab8ce4b54bebc0e342495390d(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return bets


def func_afec952bb37f4eb28ab4c1177da659b1(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return p


def func_542440f6c97e475186a629cf67c30bd9(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return budget


def func_a58808f936184171adf4ca127385aa47(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    return placed


def func_69269cfcb1df46e5bce82c1642a1d1c6(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return ret


def func_217e5e81e67d4bc592872b6e60df7c0f(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return cand


def func_e9246604588c46948de89237bdd32275(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return needed_budget


def func_dae21bdf565e4f90aae2973ca9e7486f(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest


def func_db17c5e8503b46ad8bbf8931e5b32e52(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return exclude


def func_196b7d60df08426fb70b727c94599617(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return can_replicate


def func_302cc621a81d4cc7b7db19e2f2ae6438(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return next_larger


def func_7de616bc0ae6460098bdcacd7dae81a1(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return p


def func_44c7df8fe0154deaa19b7f1e6ff1352e(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest_cnt


def func_bae7f480a58c4213a216a5cf8ad20077(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return queue


def func_f72aa9ed781d45b4876e17a7560a90d8(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return larger


def func_c09e92806bcc4f7885272b1e4feb6974(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return partial


def func_686c2cf465754d5aba6dd4d21ad63bd0(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return seen


def func_64439de98f614163993b60f484a64160(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return remaining_budget


def func_f259fde834fb4b13a3a17a7d7e838c5c(budget, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return placed


def func_eecffcd8912a4bd4abe277464c745fec(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return ret


def func_494af83cd97d487ebace16517c0fe661(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return remaining_budget


def func_5493036f88954b8a8e422c6a5156013e(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return needed_budget


def func_a6d6a0fb803f4d3fa2520dfdbbc3af04(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return p


def func_9bb601b8b58e42348644e4580a92c780(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return seen


def func_af6a65ea88db4fd5bc991157cc4480ca(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return partial


def func_122e1b9e6e1d4003b44c7593002a9839(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return cand


def func_436932b197694d079ecde2bb83b30aad(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return can_replicate


def func_1b501c76fca14d9b8fd5308bf6d224be(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest


def func_bfd213671d3b4e869689bb315b6307cc(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return next_larger


def func_22489454c8b844999cd79b33963e66f1(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return larger


def func_a331c758c9784ab78cf6f871d182799a(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return queue


def func_d5090927965c4a7196025a54a7022fd1(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest_cnt


def func_019880ec4b2440dbb24cba7e1e28797f(budget, cc, placed):
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return exclude


def func_dcb82034344c4468b735b388c2e217b4(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return ret


def func_b26814b64f404549b5593a931a3bfb60(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return cand


def func_bba94e77e5154f6790eb5c168e946eb3(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return queue


def func_d0cc8317738649fc9b5a6a6d29c3241e(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return budget


def func_ab3a93c6d790498487c1d83861a28b2b(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return larger


def func_9cf9d0b97cb44ddea84599dd104835ec(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return needed_budget


def func_b025205560c5431fa82482f088fee293(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return remaining_budget


def func_d0269692fb8443d7a4830cf0bc5ea88a(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return exclude


def func_97b3780de72f4878a4cee9aad047b18c(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return partial


def func_14ae0304cbf14f6193ba0839e004a08b(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return next_larger


def func_aae5ec4f39b54ed79122ca8c2b8eb0e3(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return can_replicate


def func_7b3c1e48b5584fedb36eb631b1bc38cd(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return placed


def func_0395d0f2ab3f49169b9db8c575279755(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return seen


def func_7b0a587ab78c489e8acd2c2c26a2aa62(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return p


def func_7b9f7d77a1484530846b95e281556200(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return bets


def func_83111d5c74864ed7af33e9075416a2f2(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest


def func_a98378c8d2a647279a6b852a3751dbde(infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)
    return lowest_cnt


def func_8a981716b1514f26bb98bf08c33d765a(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return p


def func_7c83dd71464844619bc874126c772fdb(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return next_larger


def func_ab416eb9ae064724abbd16b410e4296b(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest


def func_ad6a65eb22044352be7652f108b5cc6d(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return needed_budget


def func_654db418d7c34fa1a93ae5fab58b01ee(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return exclude


def func_15fc4e8a0c284cec909c468addd83437(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return remaining_budget


def func_29a5b238cecb4ad694a77b7534b2ce4f(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest_cnt


def func_eda06dcfdce646bbbf629d834be4b797(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return ret


def func_20448dc8039c41d9b857401a4f19a9b2(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return placed


def func_42aee3ed8aca42caaa61131c07e085ed(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return seen


def func_a6dc24c1f29e42478b59ec268fdd0519(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return cand


def func_066d3292e85d4dbe8bba252d4003607a(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return larger


def func_d28b52f8bfc345cbb2063d893733a357(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return queue


def func_b8fab3f744e044a690749e287712ffc8(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return partial


def func_eeb4fd5bb1fd4ff0a6a776000bbcd5ea(budget, cc, infile):
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return can_replicate


def func_a5ddfb768e78412f84c978280dfa3ec1(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return partial


def func_df1c8da2913d42c79ddb78d85db00554(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return budget


def func_c346738204204fa8a2f0517d43c47348(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return queue


def func_a34dd5f4cc9b462a8d0223205d510661(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest


def func_7b70629151234ebca72fa7892955b28a(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return seen


def func_338c5e27bb2245b388e911698c394bba(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return p


def func_5ee6cc2a272146c98713b6ba1c5c84d8(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return cand


def func_cee1b1c95a5f436b84a0e3f37ccb7230(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return placed


def func_f0aab3ac554e49be97ba5a453ac6f951(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return exclude


def func_91f3d95ca9f340bb9db453d3810d9ebe(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return lowest_cnt


def func_4a4750cd2da24fdeac9c72080f5c17b0(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return remaining_budget


def func_801889946caf4cbeb665ca1f748d726f(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return bets


def func_d8f6336299e140d395480b3bed0b153e(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return larger


def func_450702b6a7ba404f88a774360e0a93cb(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return ret


def func_80c4fe2f905941d78b72d8e89416307c(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return can_replicate


def func_f9a53acdeee34078bc8a8f9e1f2fba02(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return needed_budget


def func_dd766c6acd4c487dbcc7d20ffb8a5f26(cc, infile):
    budget, bets = map(int, infile.readline().split())
    placed = sorted(map(int, infile.readline().split()))
    ret = 0.0
    queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in placed
        ]
    queue = sorted(set(queue))
    seen = set(queue)
    while queue:
        lowest = queue.pop()
        if lowest == 0:
            continue
        needed_budget = (37 - len(placed)) * lowest
        for p in placed:
            needed_budget += max(0, lowest - p)
        if budget < needed_budget:
            continue
        remaining_budget = budget - needed_budget
        partial = len([p for p in placed if p <= lowest])
        lowest_cnt = 37 - len(placed) + partial
        if lowest_cnt == 0:
            continue
        larger = [p for p in placed if p > lowest]
        if larger:
            next_larger = min(larger)
            can_replicate = min(next_larger - lowest - 1, remaining_budget /
                lowest_cnt)
        else:
            can_replicate = remaining_budget / lowest_cnt
        if can_replicate > 0:
            if lowest + can_replicate not in seen:
                seen.add(lowest + can_replicate)
                queue.append(lowest + can_replicate)
            if lowest + can_replicate - 1 not in seen:
                seen.add(lowest + can_replicate - 1)
                queue.append(lowest + can_replicate - 1)
        for exclude in xrange(0, min(remaining_budget, partial) + 1):
            cand = get_expected(placed, lowest, exclude
                ) - exclude - needed_budget
            ret = max(ret, cand)('Case #%d: %.10lf' % (cc + 1, ret))
    return next_larger


def func_b8b7a77b1a6f4bf99ef8804621361945():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    return cases


def func_6a1bcd85a27e4465812016c718a0c590():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    return infile


def func_7dffabe4fddc434bb9e219906d2f093f(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return bets


def func_200a1fefdafa4ff58edca7d517cc0d2b(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return seen


def func_9d6034e01b0044799134df8197892147(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return lowest


def func_0b465a59946b43728e3275f1d08843eb(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return exclude


def func_7d0669129fb84f4ea8d73c092b70937a(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return budget


def func_ee78176ad994479d8f81063d7bc240fa(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return cand


def func_e55093cbd2724cdeb209473119f15cc6(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return p


def func_ec821cd60abb4227989f79f08aa7a81a(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return cases


def func_29b7b6e45d8048db8d9374e3d188b405(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return remaining_budget


def func_df5e424df57148b68dc3f8fbb20a362d(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return queue


def func_3aff0462414747928ef53a68dbf704db(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return placed


def func_b1f139e39f3b4b589cfb62080dc826d6(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return ret


def func_d802a1059c234b27956794f17dd467eb(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return needed_budget


def func_4e12d1c861614438b6dd563771c0323e(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return partial


def func_048af8f95e7d4a76a81bc04ffdc05ca1(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return larger


def func_9293e278d5684d57bf52ed64970f2dad(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return next_larger


def func_206b34c6d52d4deba65b83ffb1a9c614(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return can_replicate


def func_42262518132f4173821794c18ac16110(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return cc


def func_62ea4ea2090743e882d6a2256e9bb9a3(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return lowest_cnt


def func_bd00b82284714345a992f7ebbf54dcf2(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return p


def func_b5886dd541304beb96195341067cec15(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return bets


def func_9b3bb15f016e458ebcff5b85cbd6c519(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return ret


def func_ba427fcf857d457a84d56ce1ffa42b2f(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return lowest_cnt


def func_fd17d215a16d4e259eb123839dc44e6b(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return can_replicate


def func_cbc5e6bbfcc04067bc2cf1d790c57dd9(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return queue


def func_ca7919ee26e34ff6b016017b100a2550(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return remaining_budget


def func_06f2c0d5aae145cd9546fd78096f59e2(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return placed


def func_c90380a87a734f6896c56408b9dfca22(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return partial


def func_ebc1d4a254e847618367bcb50443ec7f(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return needed_budget


def func_5fbc0222a2f9485195fe43db8ab4fedc(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return next_larger


def func_d34104a35c4e4a3cbcb685a5b28ee35e(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return seen


def func_5f463628341441a0875f931d0b036ecf(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return lowest


def func_3e8097e37c8744698990cacf4781f64b(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return cc


def func_1a84b22f99534e0fa25d4b0b8a3119f0(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return budget


def func_6a02bf0f31b34598b9baf654d97e153b(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return larger


def func_010f380ed04949fcb2820d0413ebb35f():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return bets


def func_87780d1e8313481fb1762c5e101c8320():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return p


def func_f6161087a94f4ed6b547f3a471f9aecd():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return placed


def func_7ea384dbe3684b44a4a6ea6e650e4b2b():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return can_replicate


def func_f503133e24a04bb2a00b0cc9977b8295():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return lowest


def func_2868949534bb4b1e9a04051fdde991e8():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return larger


def func_800e0609b09b4b6b8bc983e503465154():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return needed_budget


def func_83762b7b93da4316a3aab32ef573f470():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return exclude


def func_54db9053ea104d67a67de804bb2df77c():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return next_larger


def func_a9d5a2789dd44d878d1db75963f878e1():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return ret


def func_e593bc4a0b794e2aa7edf31ef735a7c9():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return queue


def func_fa55a6d85cdd41e382bc88c71e4c4368():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return seen


def func_4f2c9168549b4312a451578401a40a77():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return budget


def func_adf1029c65c346708b610c4f59d5616e():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return infile


def func_b35fdd6b22ec46ac9d9a98d9cacbb335():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return remaining_budget


def func_44107efc209d4635abc6b9cc0b82a92c():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return partial


def func_3160c53328c64bc98d09d651bebd6a54():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return cc


def func_202a0ee8d63c4c88a8d433d6bb105421():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return lowest_cnt


def func_46c737324a234d238088f250b532f95f():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return cand


def func_aa03b861b3684627a0a584efb7bb44a8():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    return cases


def func_99317ad013bc4b1b9619e97a6bc4a684(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return next_larger


def func_02779287568b4632975e29caafbae94c(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return partial


def func_0c92bcbe2c9545d48af22cdf51e74101(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return can_replicate


def func_5f8169f98a3f495c86bd00d560d1ee30(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return seen


def func_f967a0dc33f94a58ba090f28d49f9a29(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return budget


def func_932f2ff1430243578714a897281e3339(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return lowest_cnt


def func_cf7fb27f2f064918b6e261fe9db81711(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return bets


def func_23bafb692d1942b1969af26dab2a4a86(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return needed_budget


def func_c336e16124104b239ec490a74a87bcbf(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return larger


def func_9a1b24f0f3fe4a268262576b49e80daa(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return ret


def func_907e76df01d8448f9433fbc6ebed54fb(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return cc


def func_4d3568ebbc554230a4929ee332587761(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return lowest


def func_1bbc126e948b4fb4a20af4d968d53a53(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return cases


def func_f44b2784caf846b4b6260ff284ee90e5(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return remaining_budget


def func_3c0477e49680400098462ae209c7b09f(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return p


def func_dc7bcd5d80cc4af98632f43ef09dcd18(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return queue


def func_ab93cf4a44ed406ea499c1ba4c14cd16(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return placed


def func_1d1c96d70cf24a139b15eb47c24fc305(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return ret


def func_aba2540eefae4bc0839f907579e112a2(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return cc


def func_8a361a215a1b4fa9902633f4f455fb96(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return lowest_cnt


def func_e6abc6b658c54688ae959bc29a50342e(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return p


def func_7203895fdde744e4b562d3c889ea0d22(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return larger


def func_7b206146484340ab9b756f447bb421dd(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return bets


def func_703a14796566413fabd4c1819b61f0ea(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return needed_budget


def func_e7cdfe0e43694d54b1cb0195a9e48a3e(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return queue


def func_34c925b20a52438ebff8bb14681388f9(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return placed


def func_91c7814a2120447cbe81ee0bfff7450d(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return next_larger


def func_39f32d839bf54c4cbb6e4f0a749276d2(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return budget


def func_2645be30df18446080ceeac71fa2aeb9(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return can_replicate


def func_8d65f3565cfc49dd8d98ca630b2e0c4d(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return partial


def func_169c2ee346a74ad2800eed357642d5de(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return seen


def func_23ab5cdf216f4d75ade922cbde9234f9(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return remaining_budget


def func_19a09d040c5e40fdb88405ced32712f0(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return lowest


def func_7e2fe86e40eb4dbfa7c6b9a72c81ffd4():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return larger


def func_349b55074a984003ac38d6088e86c313():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return p


def func_8ae20d4777344d7ebaa323d90639e74b():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return cases


def func_563e00dc9aaf4905b9b48e71e40b610c():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return infile


def func_a7c817f0031c4726bb934daa0c63371c():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return lowest_cnt


def func_45a7f875fb154f0486649a2864041a0a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return bets


def func_3587172fa6fc4595af1bbf069b2037d4():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return partial


def func_a77474959e1c4d5fbfc6429bb04b609a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return remaining_budget


def func_56f630a0254e41d0ad255d33bca7a79a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return budget


def func_d28d4aed70f74d4a93560209baae9e6e():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return ret


def func_c1fcb3daee704d658e9f2708a996f655():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return next_larger


def func_9e78026d43854e7088313bdd4791cb7c():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return lowest


def func_e107fcac013c4d24830988abd98ebc75():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return queue


def func_fb6e412ba2c8492b8c07007d244be96b():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return placed


def func_d6749a28bf14449a92861548d7a6c9b4():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return cc


def func_0061eb8e566045d6beed64764579cae5():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return can_replicate


def func_d3434989388847d3b51e0f7e5f8b5857():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return needed_budget


def func_3fc15b436aa24581b91d3cc76774260b():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    return seen


def func_e5cdc78c584a41b1b00cefe6c7e1a64d(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return remaining_budget


def func_c0f4802c353540a8a3e57907d20f5f14(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return p


def func_32f92da5b8064374bbff3ae1a95a9ccc(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return queue


def func_9b1e6967e6ab42848f1d3ed27cd1d047(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return cc


def func_5ced77ee2f2a43a78a7907b12c0d5ae7(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return partial


def func_6a3b7b272d6c4056b67e8a9055559007(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return next_larger


def func_76573fbebf97469498b38fb7d8c4f128(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return budget


def func_35821b1e41b24d3ebfa0142a6ddf5e9f(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return seen


def func_a282d4b798df4cd1beae3b6f4b64e9be(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return needed_budget


def func_f6af7e28761841e5a52ffd5257546182(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return lowest


def func_eb3ced0cb1a447f6b293a40e86b079d6(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return lowest_cnt


def func_5e7d25143c234be8a84ef55d82ed6109(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return bets


def func_17ba2d357d09415d8b7cf07dd3b9620c(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return larger


def func_2f61e386182c48aa820b73c89e22bf1a(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return placed


def func_5fa3643aded849299e12f5fa73a94102(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return cases


def func_c2a72a5ccff94d4abb6d589e22e670d4(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return ret


def func_9231b924fbe6421eaf4f6b784f77ac80(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return can_replicate


def func_c65aaa481cf048aa8ff1de6a2cc70141(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return seen


def func_1f633d0c3f81475c89eae40d71ee6d74(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return next_larger


def func_29d35e5fc2d2418cb6b2e8d18f752eb6(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return exclude


def func_c26ddaf7400741f3a903f8dcf4a1c423(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return queue


def func_67efc5e3797f4aef847d54d8ae4ed3be(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return lowest


def func_a9f63b1e792f47aa80f45a3d84e53e59(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return larger


def func_93c53d2b7b094eccbefd7d4ff4f001cf(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return partial


def func_57b64a55ad8743efab80bb79e47fc2e3(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cc


def func_2961e60591c64001be74c212fe6fff7e(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cand


def func_d764fdec180840cca2a279527a3d1f58(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return lowest_cnt


def func_ca4a02e9d847442d8f9d89006685b656(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return budget


def func_8a317ee6bac94018aa1f5f1617ab0ba4(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return can_replicate


def func_8dfbf449510249d9b6e8b6acb02fc37e(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return remaining_budget


def func_dd1974ea63924a3f9b556f24c93e7249(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return placed


def func_9e6fcae1c2e046a7b894a4f7ae4e2313(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return needed_budget


def func_5ae6017c113846148a56de3aea244f3e(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return bets


def func_aa067da96a1b4c6ab8c71dae7d10a80e(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return p


def func_93d52fae7e1b41c0ba0687bb5c4fb2bd(cases, infile):
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return ret


def func_939352cf1a7e479c973cf751a50898f5():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return larger


def func_22690e937c504b26b936afbe90d21851():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return lowest


def func_1b6e75c23f864853a2a969499b8a93e6():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return cases


def func_716e1e6bb6674ebc87c8fc65f3b7a6b2():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return budget


def func_0b36cfd5289c4861b0ef033ea1209cca():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return placed


def func_7dec3991a058450db98622b9a40ba36d():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return queue


def func_3310a99e7d0a4564ab7c0b5bceb8ce35():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return remaining_budget


def func_c6f2d008197d4716a1e9bc42e4015283():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return cc


def func_d825ac9f24754dc3a716fac98a9879f6():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return partial


def func_0155d85a5bc14b8594cfc84e80a6396a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return ret


def func_099fb04ff32a4c22b9e4ba016e6b1928():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return p


def func_c3e58b7602624a569a62473ac0aa884a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return needed_budget


def func_678c488550104a3e82711915acbcc360():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return bets


def func_f73174629b7d4755a61766d9dd7a7959():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return seen


def func_e2e83ab6a1ef46e99d5e314a2d0ed2da():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return lowest_cnt


def func_824a2e8727af4934b24398db4faf5cd4():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return can_replicate


def func_709f9aeb6b6d4202be6de93e06c5352a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return next_larger


def func_2d778199ad9f436897f9034f9b945a6a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    return infile


def func_014b59feb2644fc381264822002e4aa8(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return budget


def func_b47fcd0a7c684c9cb123a2ffecab37ea(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return remaining_budget


def func_d3176cc3602d4718929cfe23c5722530(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return needed_budget


def func_5ba526e3304049c78241e6331024092d(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return p


def func_1d569696edde4de29c3c4948ff78f225(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cc


def func_b8652e05434d470b8d537c99cce588ae(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return seen


def func_977269682686473d90d3b98aca75b209(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return bets


def func_fdbaf5c1af27404294c00e3dbd5bd629(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return next_larger


def func_ef94d039092b43b484ed7ed5587f1028(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cand


def func_f4bb888398634cd5a82ff88c00c2ec2f(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return lowest_cnt


def func_f582d5f1de4c44eb8a65ff756ae92d06(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return placed


def func_b1451abdba3b4a45861aaf51c96de390(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return partial


def func_6573a452620e48e281722d4f8df5efe3(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return queue


def func_83a32361913b4c5c8441c8d5d4eb3bf6(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return exclude


def func_127f3d26d463413381dd0090c9d9d447(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return lowest


def func_4ec44004d185463ab9848a9619ca2dee(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return larger


def func_c6abf5cb39b7496f9f14ad18d7497dbf(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cases


def func_e3af80c5f3944d29b0d12167e03f596b(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return ret


def func_cb830edc80524b599c35f414e9d9982c(infile):
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return can_replicate


def func_64c4778be53c42918793d40dbb23da44():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cases


def func_bd84959af057473b96f9a75fab5485bf():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return next_larger


def func_0df505aef94e4004a95d9ea8c9396a7c():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return infile


def func_4101d7d7b5284fc398b7616684eef88a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return exclude


def func_13edc9399c674843b3288ef8a16b6f5f():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return queue


def func_e5be29df76684581a6eacaf873b4c83e():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cand


def func_1d617c41117e451bac357e3609978e02():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return lowest


def func_cec44e1bbad94c9e9db5368ec782dfd7():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return remaining_budget


def func_af8cd4cb21684b7c9ab95d9fad76b15a():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return p


def func_fd2e9e3e224d4608bdd87ea4954a1b92():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return bets


def func_0cd51dc6e0fb40db809beb7adf5199c7():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return cc


def func_1c4867a25f1941bcb1dd9a4f74f291c3():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return placed


def func_46339166d908453395964138572ec4cc():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return seen


def func_e842db7e952e42e3b17d188db816457f():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return can_replicate


def func_f6e9c2713ce048afbfc79d1be10a8955():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return ret


def func_c08638ee53ef4cd19b851862e189a98b():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return larger


def func_6ed3c4f11f8b4c78814c263238a45e44():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return needed_budget


def func_2004547e96e34cc3b5e14d520045b4ee():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return lowest_cnt


def func_e2d5a5e6872741d2bf1d178b06ff34af():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return budget


def func_6f5d6d06c5f94046b588aa518459b9ba():
    infile = open('codejam/test_files/Y13R5P1/A.in')
    cases = int(infile.readline())
    for cc in xrange(cases):
        budget, bets = map(int, infile.readline().split())
        placed = sorted(map(int, infile.readline().split()))
        ret = 0.0
        queue = [1] + placed + [(p - 1) for p in placed] + [(p + 1) for p in
            placed]
        queue = sorted(set(queue))
        seen = set(queue)
        while queue:
            lowest = queue.pop()
            if lowest == 0:
                continue
            needed_budget = (37 - len(placed)) * lowest
            for p in placed:
                needed_budget += max(0, lowest - p)
            if budget < needed_budget:
                continue
            remaining_budget = budget - needed_budget
            partial = len([p for p in placed if p <= lowest])
            lowest_cnt = 37 - len(placed) + partial
            if lowest_cnt == 0:
                continue
            larger = [p for p in placed if p > lowest]
            if larger:
                next_larger = min(larger)
                can_replicate = min(next_larger - lowest - 1, 
                    remaining_budget / lowest_cnt)
            else:
                can_replicate = remaining_budget / lowest_cnt
            if can_replicate > 0:
                if lowest + can_replicate not in seen:
                    seen.add(lowest + can_replicate)
                    queue.append(lowest + can_replicate)
                if lowest + can_replicate - 1 not in seen:
                    seen.add(lowest + can_replicate - 1)
                    queue.append(lowest + can_replicate - 1)
            for exclude in xrange(0, min(remaining_budget, partial) + 1):
                cand = get_expected(placed, lowest, exclude
                    ) - exclude - needed_budget
                ret = max(ret, cand)
        print 'Case #%d: %.10lf' % (cc + 1, ret)
    if lowest + can_replicate not in seen:
        seen.add(lowest + can_replicate)
        queue.append(lowest + can_replicate)
    if lowest + can_replicate - 1 not in seen:
        seen.add(lowest + can_replicate - 1)
        queue.append(lowest + can_replicate - 1)
    infile.close()
    return partial
